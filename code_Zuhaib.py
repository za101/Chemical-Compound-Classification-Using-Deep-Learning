# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.
"""
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
dt = '//content/drive/My Drive/musk_csv.csv'
df = pd.read_csv(dt)
print(df)
columns = ['ID','molecule_name','conformation_name']
df.drop(columns, inplace=True, axis=1)
dataset = df.values
dataset
X = dataset[:,0:166]
Y = dataset[:,166]

from sklearn.preprocessing import StandardScaler
sc_X = StandardScaler()
X_scale1 = sc_X.fit_transform(X)
print(X_scale1)


"""
from sklearn.decomposition import PCA
pca = PCA(.95)
pca.fit(X_scale1)
X_scale = pca.transform(X_scale1)
"""

from sklearn.model_selection import train_test_split
X_train, X_val, Y_train, Y_val = train_test_split(X_scale1, Y, test_size=0.2)

#print(X_train.shape, X_val.shape, Y_train.shape, Y_val.shape)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import log_loss
import sklearn
np.random.seed(1)

N_TRAIN_SAMPLES = X_train.shape[0]
N_EPOCHS = 60
N_BATCH = 128
N_CLASSES = np.unique(Y_train)

acc_train = []
acc_validation = []

loss_train = []
loss_validation = []

epoch = 0
while epoch < N_EPOCHS:
    #print('epoch: ', epoch)
    random_perm = np.random.permutation(X_train.shape[0]) # SHUFFLING
    mini_batch_index = 0 #Starting index
    while True:
        # MINI-BATCH
        indices = random_perm[mini_batch_index:mini_batch_index + N_BATCH]
        mlp.partial_fit(X_train[indices], Y_train[indices], classes=N_CLASSES)
        
        mini_batch_index += N_BATCH#increming the mini_batch_index to the starting of the next batch.

        if mini_batch_index >= N_TRAIN_SAMPLES:
            break

    # TRAIN
    acc_train.append(mlp.score(X_train, Y_train))
    y_pred = mlp.predict(X_train)
    loss_train.append(sklearn.metrics.log_loss(Y_train,y_pred))

    # VALIDATION
    acc_validation.append(mlp.score(X_val, Y_val))
    y_predl = mlp.predict(X_val)
    loss_validation.append(sklearn.metrics.log_loss(Y_val,y_predl))
    
    epoch += 1

plt.plot(acc_train, color='green', alpha=0.8, label='Train')
plt.plot(acc_validation, color='magenta', alpha=0.8, label='Val')
plt.title("Accuracy over epochs", fontsize=14)
plt.xlabel('Epochs')
plt.legend(loc='upper left')
plt.show()

plt.plot(loss_train, color='green', alpha=0.8, label='Train')
plt.plot(loss_validation, color='magenta', alpha=0.8, label='Val')
plt.title("Loss over epochs", fontsize=14)
plt.xlabel('Epochs')
plt.legend(loc='upper left')
plt.show()

import itertools
import numpy as np
from sklearn.metrics import classification_report, confusion_matrix
def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()

cm = confusion_matrix(Y_val, y_predl)
cm_plot_labels=['No Musk','Musk']
plot_confusion_matrix(cm, cm_plot_labels,title='Confusion Matrix')

tp=cm[0][0]
fn=cm[0][1]
fp=cm[1][0]
tn=cm[1][1]
print("true pos "+' '+str(tp))
print("false neg"+' '+str(fn))
print("false pos"+' '+str(fp))
print("true neg "+' '+str(tn))

Recall=tp/(tp+fn)
Precision=tp/(tp+fp)
f_measure= 2*((Precision*Recall)/(Precision+Recall))

print("Precision: ",Precision)
print("Recall: ", Recall)
print("F-Measure: ",f_measure)

import pickle
filename = 'Finalized_Model.sav'
pickle.dump(mlp, open(filename, 'wb'))

# load the model from disk
loaded_model = pickle.load(open(filename, 'rb'))
result = loaded_model.score(X_val, Y_val)
print(result)
